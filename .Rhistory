#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value_", threshold, "%", sep = ""),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
roc <- as.data.frame(do.call(rbind, arearow)) #converting each list of AUC ratios interations in a table for each model
proc_res_med[[i]] <- apply(proc_res, 4, mean) #mean of AUC ratios interations for each model
proc_res_lt1[i] <- sum(proc_res[,4] <= 1) / length(proc_res[, 4]) #proportion of AUC ratios <= 1 for each model
p_roc <- aaa
names(p_roc) <- c(paste("Mean_AUC_ratio_at_", threshold, "%", sep = ""), "Partial_ROC")
p_roc_res <- list(p_roc, arearow)
return(p_roc_res)
})
## Use option cl.cores to choose an appropriate cluster size.
lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value_", threshold, "%", sep = ""),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
return(arearow)
})
## Use option cl.cores to choose an appropriate cluster size.
lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value_", threshold, "%", sep = ""),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
roc <- as.data.frame(do.call(rbind, arearow)) #converting each list of AUC ratios interations in a table
return(roc)
})
inrastlog <- model
## Currently fixing the number of classes to 100. But later flexibility should be given in the parameter.
inrast <- round((inrastlog / cellStats(inrastlog, max)) * 1000)
## This function should be called only once outside the loop. This function generates values for x-axis.
## As x-axis is not going to
classpixels <- a.pred.pres(inrast)
occur <- occ
extrast <- extract(inrast, occur)
## Remove all the occurrences in the class NA. As these points are not used in the calibration.
occurtbl <- cbind(occur, extrast)
occurtbl <- occurtbl[which(is.na(occurtbl[, 3]) == FALSE), ]
pointid <- seq(1:nrow(occurtbl))
occurtbl <- cbind(pointid, occurtbl)
names(occurtbl) <- c("PointID", "Longitude", "Latitude", "ClassID")
## Use option cl.cores to choose an appropriate cluster size.
lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value_", threshold, "%", sep = ""),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
roc <- as.data.frame(do.call(rbind, arearow)) #converting each list of AUC ratios interations in a table
return(roc)
})
## Use option cl.cores to choose an appropriate cluster size.
lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value_", threshold, "%", sep = ""),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
})
roc <- as.data.frame(do.call(rbind, arearow)) #converting each list of AUC ratios interations in a table
## Use option cl.cores to choose an appropriate cluster size.
lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value_", threshold, "%", sep = ""),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
return(arearow)
})
roc <- as.data.frame(do.call(rbind, arearow)) #converting each list of AUC ratios interations in a table
## Use option cl.cores to choose an appropriate cluster size.
arearow <- lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value_", threshold, "%", sep = ""),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
})
arearow
roc <- as.data.frame(do.call(rbind, arearow)) #converting each list of AUC ratios interations in a table
roc
## Use option cl.cores to choose an appropriate cluster size.
arearow <- lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value_", threshold, "%", sep = ""),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
return(arearow)
})
arearow
roc <- as.data.frame(do.call(rbind, arearow)) #converting each list of AUC ratios interations in a table
return(roc)
roc
## Use option cl.cores to choose an appropriate cluster size.
auc_ratio <- lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value_", threshold, "%", sep = ""),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
return(arearow)
})
auc_ratio
roc <- as.data.frame(do.call(rbind, auc_ratio)) #converting each list of AUC ratios interations in a table
roc
auc_ratios <- as.data.frame(do.call(rbind, auc_ratio)) #converting each list of AUC ratios interations in a table
auc_ratios
proc <- apply(auc_ratios, 4, mean) #mean of AUC ratios interations
## Use option cl.cores to choose an appropriate cluster size.
auc_ratio <- lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_at_Value"),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
return(arearow)
})
auc_ratios
auc_ratios <- as.data.frame(do.call(rbind, auc_ratio)) #converting each list of AUC ratios interations in a table
auc_ratios
## Use option cl.cores to choose an appropriate cluster size.
auc_ratio <- lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("IterationNo", paste("AUC_Value"),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
return(arearow)
})
auc_ratios <- as.data.frame(do.call(rbind, auc_ratio)) #converting each list of AUC ratios interations in a table
auc_ratios
View(auc_ratios)
apply(auc_ratios, 4, mean)
auc_ratios[,4]
proc <- apply(auc_ratios, 2, mean) #mean of AUC ratios interations
proc
p_roc <- sum(proc_res[, 4] <= 1) / length(proc_res[, 4]) #proportion of AUC ratios <= 1
p_roc <- sum(auc_ratios[, 4] <= 1) / length(auc_ratios[, 4]) #proportion of AUC ratios <= 1
p_roc
names(p_roc) <- "Partial_ROC"
p_roc_res <- list(p_roc, auc_ratios)
p_roc_res
mauc <- apply(auc_ratios, 2, mean) #mean of AUC ratios interations
mauc <- apply(auc_ratios, 2, mean)[, 4] #mean of AUC ratios interations
mauc <- apply(auc_ratios, 2, mean)[4] #mean of AUC ratios interations
mauc
proc <- sum(auc_ratios[, 4] <= 1) / length(auc_ratios[, 4]) #proportion of AUC ratios <= 1
p_roc <- c(mauc, proc)
p_roc
names(p_roc) <- c(paste("Mean_AUC_ratio_at_", threshold, "%", sep = ""), "Partial_ROC")
p_roc
p_roc_res <- list(p_roc, auc_ratios)
return(p_roc_res)
p_roc_res
auc_ratio <- lapply(X = 1:iterations, FUN = function(x) {
ll <- sample(nrow(occurtbl), round(ran.percent / 100 * nrow(occurtbl)), replace = TRUE)
occurtbl1 <- occurtbl[ll, ]
## Generate the % points within each class in this table. Write SQL, using sqldf package
occurinclass <- sqldf("Select count(*), ClassID from occurtbl1 group by ClassID order by ClassID desc")
occurinclass <- cbind(occurinclass, cumsum(occurinclass[, 1]),
cumsum(occurinclass[, 1]) / nrow(occurtbl1))
names(occurinclass) <- c("OccuCount", "ClassID", "OccuSumBelow", "Percent")
#### Raster file will contain all the classes in ClassID column, while
#### occurrences table may not have all the classes.
xytable <- g.xy.tab(classpixels, occurinclass)
arearow <- calc.auc(xytable, threshold / 100, x)
names(arearow) <- c("Iteration", paste("AUC_Value"),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
return(arearow)
})
auc_ratios <- as.data.frame(do.call(rbind, auc_ratio)) #converting each list of AUC ratios interations in a table
mauc <- apply(auc_ratios, 2, mean)[4] #mean of AUC ratios interations
proc <- sum(auc_ratios[, 4] <= 1) / length(auc_ratios[, 4]) #proportion of AUC ratios <= 1
p_roc <- c(mauc, proc)
names(p_roc) <- c(paste("Mean_AUC_ratio_at_", threshold, "%", sep = ""), "Partial_ROC")
p_roc_res <- list(p_roc, auc_ratios)
p_roc_res
auc_ratios <- rep(NA, 4)
names(auc_ratios) <- c("Iteration", paste("AUC_Value"),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
auc_ratios
p_roc <- rep(NA, 2)
names(p_roc) <- c(paste("Mean_AUC_ratio_at_", threshold, "%", sep = ""), "Partial_ROC")
auc_ratios <- rep(NA, 4)
names(auc_ratios) <- c("Iteration", paste("AUC_value"),
paste("AUC_at_", threshold, "%", sep = ""), "AUC_ratio")
p_roc_res <- list(p_roc, auc_ratios)
p_roc_res
devtools::document()
devtools::document()
data.frame(2,2)
data.frame("Total candidate models", 2956)
s <- data.frame("Total candidate models", 2956)
s1 <- data.frame("Total candidate models", 2956)
View(s)
View(s1)
s <- read.csv("C:\\Users\\Marlon\\Documents\\R\\Project_folder\\Species_1e\\ku_enm_evaluation_results\\best_models_OR_AICc")
s <- read.csv("C:\\Users\\Marlon\\Documents\\R\\Project_folder\\Species_1e\\ku_enm_evaluation_results\\best_models_OR_AICc.csv")
View(s)
s
gsub(".", "%", colnames(s)[4])
gsub("\.", "%", colnames(s)[4])
gsub("\\.", "%", colnames(s)[4])
devtools::document()
devtools::document()
?html.eval
devtools::document()
?html.eval
devtools::document()
?html.eval
devtools::document()
?ku.enm.eval
devtools::document()
?ku.enm.eval
devtools::document()
?ku.enm.eval
a <- c("s", "sa", "sds")
b <- data.frame(c(1,3,5), c(4,6,7))
a
b
data.frame(a,b)
c < - data.frame(a,b)
cd <- data.frame(a,b)
cd
cf <- data.frame(cd, cd, b)
cf
cf <- data.frame(cd, cd, b, a)
cf
b1 <- rbind(b, b, b)
b1
b2 <- b1[b1[,1] == min(b1[,1]), ]
b2
devtools::document()
devtools::load_all()
devtools::document()
setwd("C:\\Users\\Marlon\\Documents\\R\\Project_folder\\Species_1e")
m <- dir("Final_Models")
m
fm <- strsplit(m, split = "_")
fm
fms <- vector()
for (i in 1:length(fm)) {
fms[i] <- paste(fm[[i]][-length(fm[[i]])], collapse = "_")
}
fms
u_fmodels <- unique(fms)
u_fmodels
dir("Final_Models")
dir("Final_Models", pattern = unique(fms)[1])
dir("Final_Models", pattern = unique(fms)[1])[1]
dir("Final_Models", pattern = unique(fms)[1], full.names = TRUE)[1]
setwd("C:\\Users\\Marlon\\Documents\\R\\ku_enm_pub\\pemp")
devtools::load_all()
devtools::load_all()
setwd("C:\\Users\\Marlon\\Documents\\R\\ku_enm_pub\\pemp")
ku.enm.start("pemp_complete_process")
occ_joint <- "pemp_joint.csv"
occ_tra <- "pemp_train.csv"
M_var_dir <- "M_variables"
batch_cal <- "Candidate_models"
out_dir <- "Candidate_Models"
reg_mult <- c(seq(0.1,1,0.1),seq(2,6,1),8,10)
f_clas <- "all"
run <- TRUE
ku.enm.cal(occ.joint = occ_joint, occ.tra = occ_tra, M.var.dir = M_var_dir, batch = batch_cal,
out.dir = out_dir, reg.mult = reg_mult, f.clas = f_clas, run = run)
knitr::opts_chunk$set(echo = TRUE)
best <- list.files(pattern = "best")
st1 <- read.csv(best)
View(st1)
best <- list.files(pattern = "best")
st1 <- read.csv(best)
colnames(st1) <- c("Model",	"Mean_AUC_ratio",	"Partial_ROC", "gsub("\.", "%", colnames(st1)[4])", "AICc",	"delta_AICc",	"W_AICc",	"num_parameters")
best <- list.files(pattern = "best")
st1 <- read.csv(best)
colnames(st1) <- c("Model",	"Mean_AUC_ratio",	"Partial_ROC", gsub("\.", "%", colnames(st1)[4]), "AICc",	"delta_AICc",	"W_AICc",	"num_parameters")
devtools::load_all()
setwd("~/R/ku_enm_package/ku.enm")
devtools::load_all()
occ_test <- "pemp_test.csv"
out_eval <- "Calibration_results"
threshold <- 5
rand_percent <- 50
iterations <- 100
kept <- TRUE
selection <- "OR_AICc"
# Notice, some of the variables used here as arguments were already created for the previous function
ku.enm.ceval(path = out_dir, occ.joint = occ_joint, occ.tra = occ_tra, occ.test = occ_test, batch = batch_cal,
out.eval = out_eval, threshold = threshold, rand.percent = rand_percent, iterations = iterations,
kept = kept, selection = selection)
best <- list.files(pattern = "best")
st1 <- read.csv(best)
colnames(st1) <- c("Model",	"Mean_AUC_ratio",	"Partial_ROC", gsub("[.]", "%", colnames(st4)[4]), "AICc",	"delta_AICc",	"W_AICc",	"num_parameters")
best <- list.files(pattern = "best")
st1 <- read.csv(best)
colnames(st1) <- c("Model",	"Mean_AUC_ratio",	"Partial_ROC", gsub("[.]", "%", colnames(st1)[4]), "AICc",	"delta_AICc",	"W_AICc",	"num_parameters")
knitr::kable(st1, digits=c(0,3,3,3,3,3,3,0), caption = "Table 3. Performance statistics of the best models selected based on the pre-defined critera.")
setwd("~/R/ku_enm_package/ku.enm")
devtools::load_all()
batch_fin <- "Final_models"
mod_dir <- "Final_Models"
rep_n <- 10
rep_type <- "Bootstrap"
jackknife <- FALSE
G_var_dir <- "G_variables"
out_format <- "logistic"
project <- TRUE
ext_type <- "all"
write_mess <- FALSE
write_clamp <- FALSE
run1 <- TRUE
# Again, some of the variables used here as arguments were already created for the previous functions
occ_joint <- "pemp_joint.csv"
occ_tra <- "pemp_train.csv"
M_var_dir <- "M_variables"
batch_cal <- "Candidate_models"
out_dir <- "Candidate_Models"
reg_mult <- c(seq(0.1,1,0.1),seq(2,6,1),8,10)
f_clas <- "all"
run <- TRUE
occ_test <- "pemp_test.csv"
out_eval <- "Calibration_results"
threshold <- 5
rand_percent <- 50
iterations <- 100
kept <- TRUE
selection <- "OR_AICc"
# Notice, some of the variables used here as arguments were already created for the previous function
batch_fin <- "Final_models"
mod_dir <- "Final_Models"
rep_n <- 10
rep_type <- "Bootstrap"
jackknife <- FALSE
G_var_dir <- "G_variables"
out_format <- "logistic"
project <- TRUE
ext_type <- "all"
write_mess <- FALSE
write_clamp <- FALSE
run1 <- TRUE
# Again, some of the variables used here as arguments were already created for the previous functions
ku.enm.mod(occ.joint = occ_joint, M.var.dir = M_var_dir, out.eval = out_eval, batch = batch_fin, rep.n = rep_n,
rep.type = rep_type, jackknife = jackknife, out.dir = mod_dir, out.format = out_format, project = project,
G.var.dir = G_var_dir, ext.type = ext_type, write.mess = write_mess, write.clamp = write_clamp, run = run1)
occ_ind <- "pemp_ind.csv"
replicates <- TRUE
out_feval <- "Final_Models_evaluation"
# Again, some of the variables used here as arguments were already created for the previous functions
ku.enm.feval(path = mod_dir, occ.joint = occ_joint, occ.ind = occ_ind, replicates = replicates,
out.eval = out_feval, threshold = threshold, rand.percent = rand_percent,
iterations = iterations)
out_mop <- "MOP_results"
percent <- 10
normalized <- TRUE
# Again, some of the variables used here as arguments were already created for the previous functions
ku.enm.mmop(dirG = G_var_dir, dirM = M_var_dir, batch = batch_fin, out.mop = out_mop,
percent = percent, normalized = normalized)
sets_var <- "Set3"
ku.enm.mmop(dirG = G_var_dir, dirM = M_var_dir, sets.var = sets_var, out.mop = out_mop,
percent = percent, normalized = normalized)
data.frame(c(1,2,3,44,5), c("s", NA, "DS", "D", NA))
a <- data.frame(c(1,2,3,44,5), c("s", NA, "DS", "D", NA))
a
na.omit(a[a[,1] <=3, ])
a[na.omit(a[,1]) <=3, ]
rbind(a, data.frame(c(NA, "s")))
rbind(a, data.frame(NA, "s"))
a
data.frame(NA, "s")
b <- data.frame(NA, "s")
data.frame(a,b)
rbind(a,b)
names(b) <- names(a)
rbind(a,b)
c <- rbind(a,b)
na.omit(c[c[,1] <= 3, ])
c[na.omit(c[,1]) <= 3, ]
c <- data.frame(c(1,2,3,4,5,NA), c("s", NA, "d", NA, "f"))
c <- data.frame(c(1,2,3,4,5,NA), c("s", NA, "d", NA, "f", "fj"))
c[na.omit(c[,1]) <= 3, ]
c[na.omit(c[,1] <= 3), ]
c[!is.na(c[c[,1] <= 3, ][,1]),]
c
c[c[,1] == na.omit(c[,1]),]
is.na(c[,1])
c[c[,1] == !is.na(c[,1]),]
!is.na(c[,1])
c[!is.na(c[,1]),]
getwd()
devtools::load_all()
p2 <- as.person("Ronald Aylmer Fisher")
p2
devtools::load_all()
devtools::use_package(c("raster", "rmarkdown", "knitr", "yaml", "fields", "sqldf", "parallel", "rgdal", "grDevices", "ENMeval"))
packages <- c("raster", "rmarkdown", "knitr", "yaml", "fields", "sqldf", "parallel", "rgdal", "grDevices", "ENMeval")
packages <- c("raster", "rmarkdown", "knitr", "yaml", "fields", "sqldf", "parallel", "rgdal", "grDevices", "ENMeval")
for (i in 1:length(packages)) {
devtools::use_package(packages[i])
}
pack <- c("maptools")
devtools::use_package(pack, "Suggest")
description <- "This package helps with the development of critical phases
in the niche modeling process. It allows to calibrate models by
creating and testing several candidate models. Handly options for
producing final models, evaluating them, and assesing extrapolation
risks are also included as part of this package."
person(given = "Marlon E.",family = "Cobos",
email = manubio13@gmail.com, role = c("aut","cre"))
person(given = "Marlon E.",family = "Cobos",
email = "manubio13@gmail.com", role = c("aut","cre"))
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
source('~/R/ku_enm_package/ku.enm/R/ku.enm.R', echo=TRUE)
devtools::document()
devtools::document()
devtools::use_package("sp")
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::load_all()
getwd
getwd()
